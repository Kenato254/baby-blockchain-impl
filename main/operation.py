import json
from pprint import pprint
from base64 import b64encode
from dataclasses import dataclass

from script import Script


@dataclass(repr=False)
class Operation:
    """
    :sender:
        payment sender's account

    :receiver:
        payment recipient's account

    :asset:
        the amount of transfer or property to transfer

    :signature:
        signature data generated by the sender of the payment

    :OPERATIONS:
        a stack of operations
    """

    sender: object | None = None
    receiver: object | None = None
    asset: int | float | str | bytes = 0
    signature: bytes = b""

    @classmethod
    def __create_operation_helper(cls, s, r, a, sig) -> "Operation":
        """Return a new object of Operation"""
        return cls(s, r, a, sig)

    def create_operation(
        self,
        sender: object,
        recpt: object,
        asset: int | float | str | bytes,
        sig: bytes,
    ) -> "Operation":
        """
        a function that allows to create an operation with all the necessary details and signature.

        :sndr:
            account of the sender
        :recpt:
            account of recipient

        :asset:
            could be amount to transfer or property to transfer

        :sig:
            signature of the sender

        :return:
            Operation object.
        """
        return self.__create_operation_helper(sender, recpt, asset, sig)

    def verify_operation(self, index: int, prop: bool = False) -> bool:
        """
        a function that checks the operation. The main checks (relevant for the proposed implementation) include:

            verification of the transfer amount (that it does not exceed the sender's balance)
            signature verification (using the public key of the sender of the payment).

        :index:
            index of key for signing data

        :prop:
            if true check property exist

        :returns:
             true/false depending on the results of checking the operation
        """

        op_codes: str = "{0} {1} DUP SHA256 {2} EQUALVERIFY CHECKSIG".format(
            self.signature.hex(),
            str(
                (
                    self.sender.wallet["Modulus"][index],
                    self.sender.wallet["PublicKey"][index],
                )
            )
            .encode("ascii")
            .hex(),
            self.sender.get_account_id,
        )
        script: object = None
        if prop and self.sender.get_properties.get(
            self.asset, False
        ):  # Property exist check
            script: object = Script(op_codes, self.asset)
            return script.eval()

        if self.asset < self.sender.get_balance:  # Coins are sufficient check
            script: object = Script(op_codes, self.asset)
            return script.eval()
        return False

    def to_string(self) -> str:
        """
        a  function that allows to form a string from the objects of the operation.

        :returns:
             an object of the String class.
        """
        return json.dumps(self.get_operation_list, indent=1)

    def print_operation(self) -> None:
        """
        a  function to output the objects of the operation.

        :return:
            none.
        """
        print(self.to_string())

    @property
    def get_operation_list(self) -> list[dict]:
        return [
            {
                "sender": self.sender.get_account_id,
                "receiver": self.receiver.get_account_id,
                "asset": self.asset,
                "sig": self.signature.hex().strip("0"),
            }
        ]
