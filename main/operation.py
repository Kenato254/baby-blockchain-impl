import sys
import json
import struct
from dataclasses import dataclass
from pprint import pprint
from base64 import b64encode
from binascii import unhexlify

from script import Script


@dataclass(repr=False)
class Operation:
    """
    :sender:
        payment sender's account

    :receiver:
        payment recipient's account

    :asset:
        the amount of transfer or property to transfer

    :signature:
        signature data generated by the sender of the payment

    :OPERATIONS:
        a stack of operations
    """

    sender: object | None = None
    receiver: object | None = None
    asset: int | float | str | bytes = 0
    signature: bytes = b""

    @classmethod
    def __create_operation_helper(cls, s, r, a, sig) -> "Operation":
        """Return a new object of Operation"""
        return cls(s, r, a, sig)

    def create_operation(
        self, sender: object, recpt: object, asset: int | float | str | bytes
    ) -> "Operation":
        """
        a function that allows to create an operation with all the necessary details and signature.

        :sndr:
            account of the sender
        :recpt:
            account of recipient
        :asset:
            could be amount to transfer or property to transfer

        :sig:
            signature of the sender

        :return:
            Operation object.
        """
        sig: bytes = None
        if isinstance(asset, int):
            sig = sender.sign_data(
                asset.to_bytes(asset.bit_length(), "little"), 1
            )  # signs integer: coins

        elif isinstance(asset, float):
            sig = sender.sign_data(struct.pack("f", asset))  # signs float: coins

        elif isinstance(asset, bytes) or isinstance(asset, str):
            try:
                sig = sender.sign_data(
                    asset.encode("ascii")
                )  # signs string: property's id
            except AttributeError:
                sig = sender.sign_data(asset)  # signs bytes: property's id

        return self.__create_operation_helper(sender, recpt, asset, sig)

    def verify_operation(self, index: int = 1, prop: bool = False) -> bool:
        """
        a function that checks the operation. The main checks (relevant for the proposed implementation) include:

            verification of the transfer amount (that it does not exceed the sender's balance)
            signature verification (using the public key of the sender of the payment).

        :index:
            index of key for signing data

        :prop:
            if true check property exist

        :returns:
             true/false depending on the results of checking the operation
        """
        op_codes: str = "{0} {1} DUP SHA256 {2} EQUALVERIFY CHECKSIG".format(
            self.signature.hex(),
            str(
                (
                    self.sender.wallet["Modulus"][index],
                    self.sender.wallet["PublicKey"][index],
                )
            )
            .encode("ascii")
            .hex(),
            self.sender.get_account_id,
        )
        script: object = None
        if prop and self.asset in self.sender.get_properties["digital_deed"]:
            script:object = Script(op_codes, self.asset)
            return script.eval()

        if self.asset < self.sender.get_balance:
            script:object = Script(op_codes, self.asset)
            return script.eval()

    def to_string(self) -> str:
        """
        a  function that allows to form a string from the objects of the operation.

        :returns:
             an object of the String class.
        """
        return json.dumps(self.get_operation_list, indent=1)

    def print_operation(self) -> None:
        """
        a  function to output the objects of the operation.

        :return:
            none.
        """
        print(self.to_string())

    @property
    def get_operation_list(self) -> list[dict]:
        return [
            {
                "sender": self.sender.get_account_id,
                "receiver": self.receiver.get_account_id,
                "amount": self.asset,
                "sig": self.signature.hex().strip("0"),
            }
        ]


if __name__ == "__main__":
    from keypair import KeyPair
    from account import Account

    sender = Account()
    receiver = Account()
    acc_sender = sender.gen_account()
    acc_sender.add_key_pair_to_wallet(KeyPair())

    acc_receiver = sender.gen_account()
    acc_receiver.add_key_pair_to_wallet(KeyPair())

    # print(acc_sender.to_string())
    # print(acc_receiver.to_string())
    # acc_sender.print()
    # acc_receiver.print()

    op = Operation()
    operation = op.create_operation(acc_sender, acc_receiver, 100)
    # print(operation, sep="\n")
    # pprint(operation.sender)
    # pprint(operation.receiver)
    # pprint(operation.asset)
    # pprint(operation.signature)
    # operation.print_operation()
    # print(operation.verify_operation())
    # print(operation.to_string())
    # pprint(operation.get_operation_list)
    operation.print_operation()
